[{
        "pointer": "/",
        "type": "object",
        "required": [
            "geometry",
            "materials"
        ],
        "optional": [
            "preset_problem",
            "common",
            "root_path",
            "space",
            "time",
            "contact",
            "solver",
            "boundary_conditions",
            "initial_conditions",
            "output",
            "input",
            "tests"
        ],
        "doc": "Root of the configuration file."
    },
    {
        "pointer": "/common",
        "default": "",
        "type": "file",
        "extensions": [
            ".json"
        ],
        "doc": "Path to common settings will patch the current file."
    },
    {
        "pointer": "/root_path",
        "default": "",
        "type": "string",
        "doc": "Path for all relative paths, set automatically to the folder containing this json."
    },
    {
        "pointer": "/tests",
        "default": null,
        "type": "object",
        "optional": [
            "err_h1",
            "err_h1_semi",
            "err_l2",
            "err_linf",
            "err_linf_grad",
            "err_lp",
            "margin",
            "time_steps"
        ],
        "doc": "Used to test to compare different norms of solutions."
    },
    {
        "pointer": "/tests/err_h1",
        "default": 0,
        "type": "float",
        "doc": "Reference h1 solution's norm."
    },
    {
        "pointer": "/tests/err_h1_semi",
        "default": 0,
        "type": "float",
        "doc": "Reference h1 seminorm solution's norm."
    },
    {
        "pointer": "/tests/err_l2",
        "default": 0,
        "type": "float",
        "doc": "Reference $L^2$ solution's norm."
    },
    {
        "pointer": "/tests/err_linf",
        "default": 0,
        "type": "float",
        "doc": "Reference $L^\\infty$ solution's norm."
    },
    {
        "pointer": "/tests/err_linf_grad",
        "default": 0,
        "type": "float",
        "doc": "Reference $L^\\infty$ solution's gradient norm."
    },
    {
        "pointer": "/tests/err_lp",
        "default": 0,
        "type": "float",
        "doc": "Reference $L^8$ solution's gradient norm."
    },
    {
        "pointer": "/tests/margin",
        "default": 1e-5,
        "type": "float",
        "doc": "Reference tolerance used in tests."
    },
    {
        "pointer": "/tests/time_steps",
        "default": 1,
        "type": "int",
        "min": 1,
        "doc": "Number of time steps to test."
    },
    {
        "pointer": "/tests/time_steps",
        "type": "string",
        "options": [
            "all",
            "static"
        ],
        "doc": "Number of time steps to test."
    },
    {
        "pointer": "/geometry",
        "type": "list",
        "min": 1,
        "doc": "List of geometry objects."
    },
    {
        "pointer": "/geometry/*",
        "type": "object",
        "required": [
            "mesh"
        ],
        "optional": [
            "type",
            "extract",
            "transformation",
            "volume_selection",
            "surface_selection",
            "curve_selection",
            "point_selection",
            "n_refs",
            "advanced",
            "enabled",
            "is_obstacle"
        ],
        "doc": "Each geometry object stores a mesh, a set of transformations applied to it after loading, and a set of selections, which can be used to specify boundary conditions, materials, optimization parameters and other quantities that can be associated with a part of an object."
    },
    {
        "pointer": "/geometry/*/mesh",
        "type": "file",
        "extensions": [
            ".obj",
            ".msh",
            ".stl",
            ".ply",
            ".mesh"
        ],
        "doc": "Path of the mesh file to load."
    },
    {
        "pointer": "/geometry/*/type",
        "type": "string",
        "options": [
            "mesh"
        ],
        "default": "mesh",
        "doc": "Type of geometry, currently only one supported. In future we will add stuff like planes, spheres, etc."
    },
    {
        "pointer": "/geometry/*/extract",
        "type": "string",
        "options": [
            "volume",
            "edges",
            "points",
            "surface"
        ],
        "default": "volume",
        "doc": "Used to extract stuff from the mesh. Eg extract surface extracts the surface from a tet mesh."
    },
    {
        "pointer": "/geometry/*/transformation",
        "type": "object",
        "default": null,
        "optional": [
            "translation",
            "rotation",
            "rotation_mode",
            "scale",
            "dimensions"
        ],
        "doc": "Geometric transformations applied to the geometry after loading it."
    },
    {
        "pointer": "/geometry/*/transformation/rotation_mode",
        "type": "string",
        "default": "xyz",
        "doc": "Type of rotation, supported are any permutation of [xyz]+, axis_angle, quaternion, or rotation_vector."
    },
    {
        "pointer": "/geometry/*/transformation/translation",
        "type": "list",
        "default": [],
        "doc": "Translate (two entries for 2D problems or three entries for 3D problems)."
    },
    {
        "pointer": "/geometry/*/transformation/rotation",
        "type": "list",
        "default": [],
        "doc": "Rotate, in 2D, one number, the rotation angle, in 3D, three or four Euler angles, axis+angle, or a unit quaternion. Depends on rotation mode."
    },
    {
        "pointer": "/geometry/*/transformation/scale",
        "type": "list",
        "default": [],
        "doc": "Scale by specified factors along axes (two entries for 2D problems or three entries for 3D problems)."
    },
    {
        "pointer": "/geometry/*/transformation/dimensions",
        "type": "float",
        "default": 1,
        "doc": "Scale the object so that bounding box dimensions match specified dimensions, 2 entries for 2D problems, 3 entries for 3D problems."
    },
    {
        "pointer": "/geometry/*/transformation/dimensions",
        "type": "list",
        "doc": "Scale the object so that bounding box dimensions match specified dimensions, 2 entries for 2D problems, 3 entries for 3D problems."
    },
    {
        "pointer": "/geometry/*/transformation/dimensions/*",
        "type": "float",
        "default": 0
    },
    {
        "pointer": "/geometry/*/transformation/translation/*",
        "type": "float",
        "default": 0
    },
    {
        "pointer": "/geometry/*/transformation/rotation/*",
        "default": 0,
        "type": "float"
    },
    {
        "pointer": "/geometry/*/transformation/scale/*",
        "default": 0,
        "type": "float"
    },
    {
        "pointer": "/geometry/*/volume_selection",
        "type": "int",
        "default": -1,
        "doc": "Assign specified ID to all volume elements of the geometry (negative values indicate using the stored values in the MSH (default: 0))."
    },
    {
        "pointer": "/geometry/*/volume_selection",
        "type": "object",
        "required": [
            "id_offset"
        ],
        "typename": "id_offset",
        "doc": "Offsets the volume IDs loaded from the mesh."
    },
    {
        "pointer": "/geometry/*/volume_selection/id_offset",
        "type": "int",
        "default": 0,
        "doc": "Offsets the volume IDs loaded from the mesh."
    },
    {
        "pointer": "/geometry/*/volume_selection",
        "type": "list",
        "doc": "List of selection (ID assignment) operations to apply to the geometry; operations can be box, sphere, etc."
    },
    {
        "pointer": "/geometry/*/volume_selection",
        "type": "file",
        "extensions": [
            ".txt"
        ],
        "doc": "Load ids from a file; the file is required to have one ID per volume element of the geometry"
    },
    {
        "pointer": "/geometry/*/volume_selection/*",
        "type": "object",
        "required": [
            "id",
            "box"
        ],
        "optional": [
            "relative"
        ],
        "default": null,
        "typename": "box",
        "doc": "Assign the ID to all volume elements with barycenters inside an axis-aligned box given by the list of its 2 corners, one with min, the other with max coordinates along all axes.  If relative option is set to true, the coordinates of the box corners are specified in bilinear/trilinear coordinates  with respect to the bounding box of the geometry."
    },
    {
        "pointer": "/geometry/*/volume_selection/*",
        "type": "object",
        "required": [
            "id",
            "radius",
            "center"
        ],
        "optional": [
            "relative"
        ],
        "default": null,
        "typename": "sphere",
        "doc": "Assign the ID to all volume elements with barycenters inside a sphere with specified center and radius.  If relative option is set to true, the coordinates of the  center are specified in bilinear/trilinear coordinates with respect to the bounding box of the geometry, and the radius is specified relative to the bounding box diagonal length."
    },
    {
        "pointer": "/geometry/*/volume_selection/*",
        "type": "object",
        "required": [
            "id",
            "point",
            "normal"
        ],
        "optional": [
            "relative",
            "offset"
        ],
        "default": null,
        "typename": "plane",
        "doc": "Assign the ID to all volume elements with barycenters in a halfspace. The halfspace boundary plane is defined in one of two ways: (1) by a point in the plane and the normal, which points to the halfspace. (2) By a normal and the offset from the coordinate system origin along the line in the direction of the normal passing through the origin. In the former case, the option relative set to true indicates that the point position is specified in bilinear/trilinear coordinates with respect to the bounding box of the geometry."
    },
    {
        "pointer": "/geometry/*/volume_selection/*",
        "type": "object",
        "required": [
            "id",
            "axis",
            "position"
        ],
        "optional": [
            "relative"
        ],
        "default": null,
        "typename": "axis",
        "doc": "Same as halfspace, but the boundary plane is axis-aligned. The choice of axis is specified either by a string matching the regexp r\"[+-][xyzXYZ]\" or an int matching the regular expression [+-]?[123] where the sign is the side of the plane to select and letter or number indicates the axis to which the plane is perpendicular. The offset is the plane offset from the origin. If the relative option is set to true, the offset is with respect to the center of the bounding box."
    },
    {
        "pointer": "/geometry/*/volume_selection/*/id",
        "type": "int"
    },
    {
        "pointer": "/geometry/*/volume_selection/*/radius",
        "type": "float"
    },
    {
        "pointer": "/geometry/*/volume_selection/*/center",
        "type": "list",
        "min": 2,
        "max": 3
    },
    {
        "pointer": "/geometry/*/volume_selection/*/center/*",
        "type": "float"
    },
    {
        "pointer": "/geometry/*/volume_selection/*/axis",
        "type": "int"
    },
    {
        "pointer": "/geometry/*/volume_selection/*/axis",
        "type": "string"
    },
    {
        "pointer": "/geometry/*/volume_selection/*/offset",
        "type": "float"
    },
    {
        "pointer": "/geometry/*/volume_selection/*/position",
        "type": "float"
    },
    {
        "pointer": "/geometry/*/volume_selection/*/relative",
        "type": "bool",
        "default": false
    },
    {
        "pointer": "/geometry/*/volume_selection/*/point",
        "type": "list",
        "min": 2,
        "max": 3
    },
    {
        "pointer": "/geometry/*/volume_selection/*/point/*",
        "type": "float"
    },
    {
        "pointer": "/geometry/*/volume_selection/*/normal",
        "type": "list",
        "min": 2,
        "max": 3
    },
    {
        "pointer": "/geometry/*/volume_selection/*/normal/*",
        "type": "float"
    },
    {
        "pointer": "/geometry/*/volume_selection/*/box",
        "type": "list",
        "min": 2,
        "max": 2
    },
    {
        "pointer": "/geometry/*/volume_selection/*/box/*",
        "type": "list",
        "min": 2,
        "max": 3,
        "default": []
    },
    {
        "pointer": "/geometry/*/volume_selection/*/box/*/*",
        "type": "float",
        "default": 0
    },
    {
        "pointer": "/geometry/*/point_selection",
        "type": "object",
        "default": null,
        "doc": "Selection of points"
    },
    {
        "pointer": "/geometry/*/curve_selection",
        "type": "object",
        "default": null,
        "doc": "Selection of curves"
    },
    {
        "pointer": "/geometry/*/surface_selection",
        "type": "int",
        "default": 0,
        "doc": "Assign specified ID to all surface elements of the geometry"
    },
    {
        "pointer": "/geometry/*/surface_selection",
        "type": "object",
        "optional": [
            "threshold",
            "offset"
        ],
        "typename": "bbox",
        "doc": "Assigns ids to sides touching the bbox of the model using a threshold. Assigns 1+offset to left, 2+offset to bottom, 3+offset to right, 4+offset to top, 5+offset to front, 6+offset to back, 7+offset to everything else."
    },
    {
        "pointer": "/geometry/*/surface_selection/threshold",
        "type": "float",
        "default": -1
    },
    {
        "pointer": "/geometry/*/surface_selection/offset",
        "type": "int",
        "default": 0
    },
    {
        "pointer": "/geometry/*/surface_selection",
        "type": "list",
        "doc": "List of selection (ID assignment) operations to apply to the geometry; operations can be box, sphere, etc."
    },
    {
        "pointer": "/geometry/*/surface_selection",
        "type": "file",
        "extensions": [
            ".txt"
        ],
        "doc": "Load ids from a file; the file has a list of surface elements of the geometry specified as triples of vertex indices, with one ID for each; each triple must correspond to a surface element"
    },
    {
        "pointer": "/geometry/*/surface_selection/*",
        "type": "object",
        "required": [
            "id",
            "box"
        ],
        "optional": [
            "relative"
        ],
        "default": null,
        "typename": "box",
        "doc": "Assign the ID to all surface elements with barycenters inside an axis-aligned box given by the list of its 2 corners, one with min, the other with max coordinates along all axes.  If relative option is set to true, the coordinates of the box corners are specified in bilinear/trilinear coordinates  with respect to the bounding box of the geometry."
    },
    {
        "pointer": "/geometry/*/surface_selection/*",
        "type": "object",
        "required": [
            "id",
            "radius",
            "center"
        ],
        "optional": [
            "relative"
        ],
        "default": null,
        "typename": "sphere",
        "doc": "Assign the ID to all surface elements with barycenters inside a sphere with specified center and radius.  If relative option is set to true, the coordinates of the  center are specified in bilinear/trilinear coordinates with respect to the bounding box of the geometry, and the radius is specified relative to the bounding box diagonal length."
    },
    {
        "pointer": "/geometry/*/surface_selection/*",
        "type": "object",
        "required": [
            "id",
            "point",
            "normal"
        ],
        "optional": [
            "relative",
            "offset"
        ],
        "default": null,
        "typename": "plane",
        "doc": "Assign the ID to all surface elements with barycenters in a halfspace. The halfspace boundary plane is defined in one of two ways: (1) by a point in the plane and the normal, which points to the halfspace. (2) By a normal and the offset from the coordinate system origin along the line in the direction of the normal passing through the origin. In the former case, the option relative set to true indicates that the point position is specified in bilinear/trilinear coordinates with respect to the bounding box of the geometry."
    },
    {
        "pointer": "/geometry/*/surface_selection/*",
        "type": "object",
        "required": [
            "id",
            "axis",
            "position"
        ],
        "optional": [
            "relative"
        ],
        "default": null,
        "typename": "axis",
        "doc": "Same as halfspace, but the boundary plane is axis-aligned. The choice of axis is specified either by a string matching the regexp r\"[+-][xyzXYZ]\" or an int matching the regular expression [+-]?[123] where the sign is the side of the plane to select and letter or number indicates the axis to which the plane is perpendicular. The offset is the plane offset from the origin. If the relative option is set to true, the offset is with respect to the center of the bounding box."
    },
    {
        "pointer": "/geometry/*/surface_selection/*/id",
        "type": "int"
    },
    {
        "pointer": "/geometry/*/surface_selection/*/radius",
        "type": "float"
    },
    {
        "pointer": "/geometry/*/surface_selection/*/center",
        "type": "list",
        "min": 2,
        "max": 3
    },
    {
        "pointer": "/geometry/*/surface_selection/*/center/*",
        "type": "float"
    },
    {
        "pointer": "/geometry/*/surface_selection/*/axis",
        "type": "int"
    },
    {
        "pointer": "/geometry/*/surface_selection/*/axis",
        "type": "string"
    },
    {
        "pointer": "/geometry/*/surface_selection/*/offset",
        "type": "float"
    },
    {
        "pointer": "/geometry/*/surface_selection/*/position",
        "type": "float"
    },
    {
        "pointer": "/geometry/*/surface_selection/*/relative",
        "type": "bool",
        "default": false
    },
    {
        "pointer": "/geometry/*/surface_selection/*/point",
        "type": "list",
        "min": 2,
        "max": 3
    },
    {
        "pointer": "/geometry/*/surface_selection/*/point/*",
        "type": "float"
    },
    {
        "pointer": "/geometry/*/surface_selection/*/normal",
        "type": "list",
        "min": 2,
        "max": 3
    },
    {
        "pointer": "/geometry/*/surface_selection/*/normal/*",
        "type": "float"
    },
    {
        "pointer": "/geometry/*/surface_selection/*/box",
        "type": "list",
        "min": 2,
        "max": 2
    },
    {
        "pointer": "/geometry/*/surface_selection/*/box/*",
        "type": "list",
        "min": 2,
        "max": 3,
        "default": []
    },
    {
        "pointer": "/geometry/*/surface_selection/*/box/*/*",
        "type": "float",
        "default": 0
    },
    {
        "pointer": "/geometry/*/n_refs",
        "type": "int",
        "default": 0,
        "doc": "number of uniform refinements"
    },
    {
        "pointer": "/geometry/*/advanced",
        "type": "object",
        "optional": [
            "normalize_mesh",
            "force_linear_geometry",
            "refinement_location",
            "min_component"
        ],
        "default": null,
        "doc": "Advanced options for geometry"
    },
    {
        "pointer": "/geometry/*/advanced/normalize_mesh",
        "type": "bool",
        "default": false,
        "doc": "Rescale the mesh to it fits in the biunit cube"
    },
    {
        "pointer": "/geometry/*/advanced/force_linear_geometry",
        "type": "bool",
        "default": false,
        "doc": "Discard high-order nodes for curved geometries"
    },
    {
        "pointer": "/geometry/*/advanced/refinement_location",
        "type": "float",
        "default": 0.5,
        "doc": "parametric location of the refinement"
    },
    {
        "pointer": "/geometry/*/advanced/min_component",
        "type": "int",
        "default": -1,
        "doc": "Size of the minumum component for collision"
    },
    {
        "pointer": "/geometry/*/is_obstacle",
        "type": "bool",
        "default": false,
        "doc": "The geometry elements are not included in deforming geometry, only in collision computations"
    },
    {
        "pointer": "/geometry/*/enabled",
        "type": "bool",
        "default": true,
        "doc": "Skips the geometry if false"
    },
    {
        "pointer": "/space",
        "default": null,
        "type": "object",
        "optional": [
            "discr_order",
            "pressure_discr_order",
            "use_p_ref",
            "advanced"
        ],
        "doc": "Options related to the FE space."
    },
    {
        "pointer": "/space/discr_order",
        "default": 1,
        "type": "int",
        "doc": "Lagrange element order for the space for the main unknown, for all elements."
    },
    {
        "pointer": "/space/discr_order",
        "type": "file",
        "extensions": [
            ".txt",
            ".bin"
        ],
        "doc": "Path to file containing Lagrange element order for the space for the main unknown per element."
    },
    {
        "pointer": "/space/discr_order",
        "type": "list",
        "doc": "List of Lagrange element order for the space for the main unknown with volume IDs."
    },
    {
        "pointer": "/space/discr_order/*",
        "type": "object",
        "required": [
            "id",
            "order"
        ],
        "doc": "Lagrange element order for the a space tagged with volume ID for the main unknown."
    },
    {
        "pointer": "/space/discr_order/*/id",
        "type": "int",
        "doc": "Volume selection ID to apply the discr_order to."
    },
    {
        "pointer": "/space/discr_order/*/id",
        "type": "list",
        "doc": "List of volume selection IDs to apply the discr_order to."
    },
    {
        "pointer": "/space/discr_order/*/id/*",
        "type": "int",
        "doc": "Volume selection ID to apply the discr_order to."
    },
    {
        "pointer": "/space/discr_order/*/order",
        "type": "int",
        "doc": "Lagrange element order for the space for the main unknown, for all elements."
    },
    {
        "pointer": "/space/pressure_discr_order",
        "default": 1,
        "type": "int",
        "doc": " Lagrange element order for the space for the pressure unknown, for all elements."
    },
    {
        "pointer": "/space/use_p_ref",
        "default": false,
        "type": "bool",
        "doc": "Perform a priori p-refinement based on element shape, as described in 'Decoupling..' paper."
    },
    {
        "pointer": "/space/advanced",
        "default": null,
        "type": "object",
        "optional": [
            "discr_order_max",
            "serendipity",
            "isoparametric",
            "use_spline",
            "bc_method",
            "n_boundary_samples",
            "quadrature_order",
            "mass_quadrature_order",
            "poly_bases",
            "integral_constraints",
            "n_harmonic_samples",
            "force_no_ref_for_harmonic",
            "B",
            "h1_formula",
            "count_flipped_els"
        ],
        "doc": "Advanced settings for the FE space."
    },
    {
        "pointer": "/space/advanced/discr_order_max",
        "default": 4,
        "type": "int",
        "doc": "Maximal discretization order in adaptive p-refinement and hp-refinement"
    },
    {
        "pointer": "/space/advanced/serendipity",
        "default": false,
        "type": "bool",
        "doc": "Use serendipity elements for quad/hex elements of degree 2."
    },
    {
        "pointer": "/space/advanced/isoparametric",
        "default": false,
        "type": "bool",
        "doc": "Forces geometric map basis to be the same degree as the main variable basis, irrespective of the degree associated with the geom. map degrees associated with the elements of the geometry."
    },
    {
        "pointer": "/space/advanced/use_spline",
        "default": false,
        "type": "bool",
        "doc": "Use bi/triquadratic spline basis for quad/hex elements not adjacent to polyhedral elements, see 'PolySpline..' paper for details."
    },
    {
        "pointer": "/space/advanced/bc_method",
        "default": "lsq",
        "options": [
            "lsq",
            "sample"
        ],
        "type": "string",
        "doc": "Method for imposing analytic Dirichet boundary conditions. If 'lsq' (least-squares fit), then the bc function is sampled at quadrature points, and the FEspace nodal values on the boundary are determined by minimizing L2 norm of the difference. If 'sample', then the analytic bc function is sampled at the boundary nodes."
    },
    {
        "pointer": "/space/advanced/n_boundary_samples",
        "default": -1,
        "type": "int",
        "doc": "Per-element number of boundary samples for analytic Dirichlet and Neumann boundary conditions."
    },
    {
        "pointer": "/space/advanced/quadrature_order",
        "default": -1,
        "type": "int",
        "doc": "Minimal quadrature order to use in matrix and rhs assembly; the actual order is determined as min(2*(p-1)+1,quadrature_order)."
    },
    {
        "pointer": "/space/advanced/mass_quadrature_order",
        "default": -1,
        "type": "int",
        "doc": "Minimal quadrature order to use in mass matrix assembler; the actual order is determined as min(2*p+1,quadrature_order)"
    },
    {
        "pointer": "/space/advanced/poly_bases",
        "default": "MFSHarmonic",
        "options": [
            "MFSHarmonic",
            "MeanValue"
        ],
        "type": "string",
        "doc": "Type of basis to use for a polygonal element, one of MFSHarmonic, MeanValue, see 'PolySpline..' paper for details."
    },
    {
        "pointer": "/space/advanced/integral_constraints",
        "default": 2,
        "type": "int",
        "doc": "Number of constraints for non-conforming polygonal basis;  0, 1, or 2; see 'PolySpline..' paper for details."
    },
    {
        "pointer": "/space/advanced/n_harmonic_samples",
        "default": 10,
        "type": "int",
        "doc": "If MFSHarmonics is used for a polygonal element, number of collocation samples used in the basis construction;see 'PolySpline..' paper for details."
    },
    {
        "pointer": "/space/advanced/force_no_ref_for_harmonic",
        "default": false,
        "type": "bool",
        "doc": "If true, do not do uniform global refinement if the mesh contains polygonal elements."
    },
    {
        "pointer": "/space/advanced/B",
        "default": 3,
        "type": "int",
        "doc": "The target deviation of the error on elements from perfect element error, for a priori geometry-dependent p-refinement, see 'Decoupling .. ' paper."
    },
    {
        "pointer": "/space/advanced/h1_formula",
        "default": false,
        "type": "bool",
        "doc": ""
    },
    {
        "pointer": "/space/advanced/count_flipped_els",
        "default": true,
        "type": "bool",
        "doc": "Count the number of elements with Jacobian of the geometric map not positive at quadrature points."
    },
    {
        "pointer": "/time",
        "default": "skip",
        "type": "object",
        "required": [
            "tend",
            "dt"
        ],
        "optional": [
            "t0",
            "integrator"
        ],
        "doc": "The time parameters: start time `t0`, end time `tend`, time step `dt`."
    },
    {
        "pointer": "/time",
        "type": "object",
        "required": [
            "time_steps",
            "dt"
        ],
        "optional": [
            "t0",
            "integrator"
        ],
        "doc": "The time parameters: start time `t0`, time step `dt`, number of time steps."
    },
    {
        "pointer": "/time",
        "type": "object",
        "required": [
            "time_steps",
            "tend"
        ],
        "optional": [
            "t0",
            "integrator"
        ],
        "doc": "The time parameters: start time `t0`, end time `tend`, number of time steps."
    },
    {
        "pointer": "/time/t0",
        "type": "float",
        "min": 0,
        "default": 0,
        "doc": "Startning time"
    },
    {
        "pointer": "/time/tend",
        "type": "float",
        "min": 0,
        "doc": "Ending time"
    },
    {
        "pointer": "/time/dt",
        "type": "float",
        "min": 0,
        "doc": "Time step size $\\Delta t$"
    },
    {
        "pointer": "/time/time_steps",
        "type": "int",
        "min": 0,
        "doc": "Number of time steps"
    },
    {
        "pointer": "/time/integrator",
        "type": "string",
        "default": "ImplicitEuler",
        "options": [
            "ImplicitEuler",
            "BDF",
            "ImplicitNewmark"
        ],
        "doc": "Time integrator"
    },
    {
        "pointer": "/time/integrator",
        "type": "object",
        "type_name": "ImplicitEuler",
        "required": [
            "type"
        ],
        "doc": "Implicit Euler time integration"
    },
    {
        "pointer": "/time/integrator",
        "type": "object",
        "type_name": "BDF",
        "required": [
            "type"
        ],
        "optional": [
            "steps"
        ],
        "doc": "Backwards differentiation formula time integration"
    },
    {
        "pointer": "/time/integrator",
        "type": "object",
        "type_name": "ImplicitNewmark",
        "required": [
            "type"
        ],
        "optional": [
            "gamma",
            "beta"
        ],
        "doc": "Implicit Newmark time integration"
    },
    {
        "pointer": "/time/integrator/type",
        "type": "string",
        "options": [
            "ImplicitEuler",
            "BDF",
            "ImplicitNewmark"
        ],
        "doc": "Type of time integrator to use"
    },
    {
        "pointer": "/time/integrator/gamma",
        "type": "float",
        "default": 0.5,
        "min": 0,
        "max": 1,
        "doc": "Newmark gamma"
    },
    {
        "pointer": "/time/integrator/beta",
        "type": "float",
        "default": 0.25,
        "min": 0,
        "max": 0.5,
        "doc": "Newmark beta"
    },
    {
        "pointer": "/time/integrator/steps",
        "type": "int",
        "default": 1,
        "min": 1,
        "max": 6,
        "doc": "BDF order"
    },
    {
        "pointer": "/contact",
        "default": null,
        "type": "object",
        "optional": [
            "enabled",
            "dhat",
            "dhat_percentage",
            "epsv",
            "friction_coefficient"
        ],
        "doc": "Contact handling parameters."
    },
    {
        "pointer": "/contact/enabled",
        "default": false,
        "type": "bool",
        "doc": "True if contact handling is enabled."
    },
    {
        "pointer": "/contact/dhat",
        "default": 0.001,
        "min": 0,
        "type": "float",
        "doc": "Contact barrier activation distance."
    },
    {
        "pointer": "/contact/dhat_percentage",
        "default": 0.8,
        "type": "float",
        "doc": "$\\hat{d}$ as percentage of the diagonal of the bounding box"
    },
    {
        "pointer": "/contact/epsv",
        "default": 0.001,
        "min": 0,
        "type": "float",
        "doc": "Friction smoothing parameter."
    },
    {
        "pointer": "/contact/friction_coefficient",
        "default": 0,
        "type": "float",
        "doc": "Coefficient of friction (global)"
    },
    {
        "pointer": "/solver",
        "default": null,
        "type": "object",
        "optional": [
            "linear",
            "nonlinear",
            "augmented_lagrangian",
            "contact",
            "ignore_inertia",
            "advanced"
        ],
        "doc": "The settings for the solver including linear solver, nonlinear solver, and some advanced options."
    },
    {
        "pointer": "/solver/linear",
        "default": null,
        "type": "object",
        "optional": [
            "solver",
            "precond",
            "Eigen::LeastSquaresConjugateGradient",
            "Eigen::DGMRES",
            "Eigen::ConjugateGradient",
            "Eigen::BiCGSTAB",
            "Eigen::GMRES",
            "Eigen::MINRES",
            "Pardiso",
            "Hypre",
            "AMGCL"
        ],
        "doc": "Settings for the linear solver."
    },
    {
        "pointer": "/solver/linear/solver",
        "default": "",
        "type": "string",
        "doc": "Linear solver type.",
        "options": [
            "Eigen::SimplicialLDLT",
            "Eigen::SparseLU",
            "Eigen::CholmodSupernodalLLT",
            "Eigen::UmfPackLU",
            "Eigen::SuperLU",
            "Eigen::PardisoLDLT",
            "Eigen::PardisoLU",
            "Pardiso",
            "Hypre",
            "AMGCL",
            "Eigen::LeastSquaresConjugateGradient",
            "Eigen::DGMRES",
            "Eigen::ConjugateGradient",
            "Eigen::BiCGSTAB",
            "Eigen::GMRES",
            "Eigen::MINRES"
        ]
    },
    {
        "pointer": "/solver/linear/precond",
        "default": "",
        "type": "string",
        "doc": "Preconditioner used if using an iterative linear solver.",
        "options": [
            "Eigen::IdentityPreconditioner",
            "Eigen::DiagonalPreconditioner",
            "Eigen::IncompleteCholesky",
            "Eigen::LeastSquareDiagonalPreconditioner",
            "Eigen::IncompleteLUT"
        ]
    },
    {
        "pointer": "/solver/linear/Eigen::LeastSquaresConjugateGradient",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "tolerance"
        ],
        "doc": "Settings for the Eigen's Least Squares Conjugate Gradient solver."
    },
    {
        "pointer": "/solver/linear/Eigen::DGMRES",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "tolerance"
        ],
        "doc": "Settings for the Eigen's DGMRES solver."
    },
    {
        "pointer": "/solver/linear/Eigen::ConjugateGradient",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "tolerance"
        ],
        "doc": "Settings for the Eigen's Conjugate Gradient solver."
    },
    {
        "pointer": "/solver/linear/Eigen::BiCGSTAB",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "tolerance"
        ],
        "doc": "Settings for the Eigen's BiCGSTAB solver."
    },
    {
        "pointer": "/solver/linear/Eigen::GMRES",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "tolerance"
        ],
        "doc": "Settings for the Eigen's GMRES solver."
    },
    {
        "pointer": "/solver/linear/Eigen::MINRES",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "tolerance"
        ],
        "doc": "Settings for the Eigen's MINRES solver."
    },
    {
        "pointer": "/solver/linear/Pardiso",
        "default": null,
        "type": "object",
        "optional": [
            "mtype"
        ],
        "doc": "Settings for the Pardiso solver."
    },
    {
        "pointer": "/solver/linear/Hypre",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "pre_max_iter",
            "tolerance"
        ],
        "doc": "Settings for the Hypre solver."
    },
    {
        "pointer": "/solver/linear/AMGCL",
        "default": null,
        "type": "object",
        "optional": [
            "solver",
            "precond"
        ],
        "doc": "Settings for the AMGCL solver."
    },
    {
        "pointer": "/solver/linear/Eigen::LeastSquaresConjugateGradient/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/solver/linear/Eigen::LeastSquaresConjugateGradient/tolerance",
        "default": 1e-12,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/solver/linear/Eigen::DGMRES/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/solver/linear/Eigen::DGMRES/tolerance",
        "default": 1e-12,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/solver/linear/Eigen::ConjugateGradient/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/solver/linear/Eigen::ConjugateGradient/tolerance",
        "default": 1e-12,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/solver/linear/Eigen::BiCGSTAB/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/solver/linear/Eigen::BiCGSTAB/tolerance",
        "default": 1e-12,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/solver/linear/Eigen::GMRES/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/solver/linear/Eigen::GMRES/tolerance",
        "default": 1e-12,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/solver/linear/Eigen::MINRES/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/solver/linear/Eigen::MINRES/tolerance",
        "default": 1e-12,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/solver/linear/Pardiso/mtype",
        "default": 11,
        "type": "int",
        "options": [1, 2, -2, 3, 4, -4, 6, 11, 13],
        "doc": "Matrix type."
    },
    {
        "pointer": "/solver/linear/Hypre/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/solver/linear/Hypre/pre_max_iter",
        "default": 1,
        "type": "int",
        "doc": "Maximum number of pre iterations."
    },
    {
        "pointer": "/solver/linear/Hypre/tolerance",
        "default": 1e-10,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/solver/linear/AMGCL/solver",
        "default": null,
        "type": "object",
        "optional": [
            "tol",
            "maxiter",
            "type"
        ],
        "doc": "Solver settings for the AMGCL."
    },
    {
        "pointer": "/solver/linear/AMGCL/precond",
        "default": null,
        "type": "object",
        "optional": [
            "relax",
            "class",
            "max_levels",
            "direct_coarse",
            "ncycle",
            "coarsening"
        ],
        "doc": "Preconditioner settings for the AMGCL."
    },
    {
        "pointer": "/solver/linear/AMGCL/solver/maxiter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/solver/linear/AMGCL/solver/tol",
        "default": 1e-10,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/solver/linear/AMGCL/solver/type",
        "default": "cg",
        "type": "string",
        "doc": "Type of solver to use."
    },
    {
        "pointer": "/solver/linear/AMGCL/precond/relax",
        "default": null,
        "type": "object",
        "optional": [
            "degree",
            "type",
            "power_iters",
            "higher",
            "lower",
            "scale"
        ],
        "doc": "Preconditioner settings for the AMGCL."
    },
    {
        "pointer": "/solver/linear/AMGCL/precond/class",
        "default": "amg",
        "type": "string",
        "doc": "Type of preconditioner to use."
    },
    {
        "pointer": "/solver/linear/AMGCL/precond/max_levels",
        "default": 6,
        "type": "int",
        "doc": "Maximum number of levels."
    },
    {
        "pointer": "/solver/linear/AMGCL/precond/direct_coarse",
        "default": false,
        "type": "bool",
        "doc": "Use direct solver for the coarsest level."
    },
    {
        "pointer": "/solver/linear/AMGCL/precond/ncycle",
        "default": 2,
        "type": "int",
        "doc": "Number of cycles."
    },
    {
        "pointer": "/solver/linear/AMGCL/precond/coarsening",
        "default": null,
        "type": "object",
        "optional": [
            "type",
            "estimate_spectral_radius",
            "relax",
            "aggr"
        ],
        "doc": "Coarsening parameters."
    },
    {
        "pointer": "/solver/linear/AMGCL/precond/relax/degree",
        "default": 16,
        "type": "int",
        "doc": "Degree of the polynomial."
    },
    {
        "pointer": "/solver/linear/AMGCL/precond/relax/type",
        "default": "chebyshev",
        "type": "string",
        "doc": "Type of relaxation to use."
    },
    {
        "pointer": "/solver/linear/AMGCL/precond/relax/power_iters",
        "default": 100,
        "type": "int",
        "doc": "Number of power iterations."
    },
    {
        "pointer": "/solver/linear/AMGCL/precond/relax/higher",
        "default": 2,
        "type": "float",
        "doc": "Higher level relaxation."
    },
    {
        "pointer": "/solver/linear/AMGCL/precond/relax/lower",
        "default": 0.008333333333,
        "type": "float",
        "doc": "Lower level relaxation."
    },
    {
        "pointer": "/solver/linear/AMGCL/precond/relax/scale",
        "default": true,
        "type": "bool",
        "doc": "Scale."
    },
    {
        "pointer": "/solver/linear/AMGCL/precond/coarsening/type",
        "default": "smoothed_aggregation",
        "type": "string",
        "doc": "Coarsening type."
    },
    {
        "pointer": "/solver/linear/AMGCL/precond/coarsening/estimate_spectral_radius",
        "default": true,
        "type": "bool",
        "doc": "Should the spectral radius be estimated."
    },
    {
        "pointer": "/solver/linear/AMGCL/precond/coarsening/relax",
        "default": 1,
        "type": "float",
        "doc": "Coarsening relaxation."
    },
    {
        "pointer": "/solver/linear/AMGCL/precond/coarsening/aggr",
        "default": null,
        "type": "object",
        "optional": [
            "eps_strong"
        ],
        "doc": "Aggregation settings."
    },
    {
        "pointer": "/solver/linear/AMGCL/precond/coarsening/aggr/eps_strong",
        "default": 0,
        "type": "float",
        "doc": "Aggregation epsilon strong."
    },
    {
        "pointer": "/solver/nonlinear",
        "default": null,
        "type": "object",
        "optional": [
            "solver",
            "f_delta",
            "grad_norm",
            "first_grad_norm_tol",
            "max_iterations",
            "use_grad_norm",
            "relative_gradient",
            "line_search"
        ],
        "doc": "Settings for nonlinear solver. Interior-loop linear solver settings are defined in the solver/linear section."
    },
    {
        "pointer": "/solver/nonlinear/solver",
        "default": "newton",
        "type": "string",
        "options": [
            "newton",
            "lbfgs"
        ],
        "doc": "Nonlinear solver type"
    },
    {
        "pointer": "/solver/nonlinear/f_delta",
        "default": 1e-10,
        "type": "float",
        "doc": "Stopping criterion: minimal change of the energy f for the iterations to continue."
    },
    {
        "pointer": "/solver/nonlinear/grad_norm",
        "default": 1e-08,
        "type": "float",
        "doc": "Stopping criterion: Minimal gradient norm for the iterations to continue."
    },
    {
        "pointer": "/solver/nonlinear/first_grad_norm_tol",
        "default": 1e-10,
        "type": "float",
        "doc": "Minimal gradient norm for the iterations to not start, assume we already are at a minimum."
    },
    {
        "pointer": "/solver/nonlinear/max_iterations",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations for a nonlinear solve."
    },
    {
        "pointer": "/solver/nonlinear/use_grad_norm",
        "default": true,
        "type": "bool",
        "doc": "If true, enable gradient-norm stopping criterion, absolute (if relative_gradient is false), or relative to the initial gradient magnitude before the first iteration, otherwise."
    },
    {
        "pointer": "/solver/nonlinear/relative_gradient",
        "default": false,
        "type": "bool",
        "doc": "If true, use relative gradient norm threshold, use absolute otherwise"
    },
    {
        "pointer": "/solver/nonlinear/line_search",
        "default": null,
        "type": "object",
        "optional": [
            "method",
            "use_grad_norm_tol"
        ],
        "doc": "Settings for line-search in the nonlinear solver"
    },
    {
        "pointer": "/solver/nonlinear/line_search/method",
        "default": "backtracking",
        "type": "string",
        "options": [
            "armijo",
            "armijo_alt",
            "backtracking",
            "more_thuente",
            "none"
        ],
        "doc": "Line-search type"
    },
    {
        "pointer": "/solver/nonlinear/line_search/use_grad_norm_tol",
        "default": 0.0001,
        "type": "float",
        "doc": "When the energy is smaller than use_grad_norm_tol, line-search uses norm of gradient instead of energy"
    },
    {
        "pointer": "/solver/augmented_lagrangian",
        "default": null,
        "type": "object",
        "optional": [
            "initial_weight",
            "max_weight",
            "force"
        ],
        "doc": "Parameters for the AL for imposing Dirichlet BCs. If the bc are not imposable, we add $w\\|u - bc\\|^2$ to the energy ($u$ is the solution at the Dirichlet nodes and $bc$ are the Dirichlet values). After convergence, we try to impose bc again, in case of failure we double $w$ until `max_weight`."
    },
    {
        "pointer": "/solver/augmented_lagrangian/initial_weight",
        "default": 1000000.0,
        "type": "float",
        "doc": "Initial weight for AL"
    },
    {
        "pointer": "/solver/augmented_lagrangian/max_weight",
        "default": 100000000000.0,
        "type": "float",
        "doc": "Maximum AL weight"
    },
    {
        "pointer": "/solver/augmented_lagrangian/force",
        "default": false,
        "type": "bool",
        "doc": "Always enable AL, even when BC can be imposed"
    },
    {
        "pointer": "/solver/contact",
        "default": null,
        "type": "object",
        "optional": [
            "CCD",
            "friction_iterations",
            "friction_convergence_tol",
            "barrier_stiffness"
        ],
        "doc": "Settings for contact handling in the solver."
    },
    {
        "pointer": "/solver/contact/CCD",
        "default": null,
        "type": "object",
        "optional": [
            "broad_phase",
            "tolerance",
            "max_iterations"
        ],
        "doc": "CCD options"
    },
    {
        "pointer": "/solver/contact/CCD/broad_phase",
        "default": "hash_grid",
        "type": "string",
        "options": [
            "hash_grid",
            "HG",
            "brute_force",
            "BF",
            "spatial_hash",
            "SH",
            "sweep_and_tiniest_queue",
            "STQ",
            "sweep_and_tiniest_queue_gpu",
            "STQ_GPU"
        ],
        "doc": "Broad phase collision-detection algorithm to use"
    },
    {
        "pointer": "/solver/contact/CCD/tolerance",
        "default": 1e-06,
        "type": "float",
        "doc": "CCD tolerance"
    },
    {
        "pointer": "/solver/contact/CCD/max_iterations",
        "default": 1000000,
        "type": "int",
        "doc": "Maximum number of iterations for continuous collision detection"
    },
    {
        "pointer": "/solver/contact/friction_iterations",
        "default": 1,
        "type": "int",
        "doc": "Maximum number of update iterations for lagged friction formulation (see IPC paper)."
    },
    {
        "pointer": "/solver/contact/friction_convergence_tol",
        "default": 0.01,
        "type": "float",
        "doc": "Tolerence for friction convergence"
    },
    {
        "pointer": "/solver/contact/barrier_stiffness",
        "default": "adaptive",
        "options": [
            "adaptive"
        ],
        "type": "string",
        "doc": "How coefficient of clamped log-barrier function for contact is updated"
    },
    {
        "pointer": "/solver/contact/barrier_stiffness",
        "type": "float",
        "doc": "The coefficient of clamped log-barrier function value when not adaptive"
    },
    {
        "pointer": "/solver/ignore_inertia",
        "default": false,
        "type": "bool",
        "doc": "Ignore inertia in time dependent. Used for doing incremental load."
    },
    {
        "pointer": "/solver/advanced",
        "default": null,
        "type": "object",
        "optional": [
            "cache_size",
            "lump_mass_matrix",
            "lagged_regularization_weight",
            "lagged_regularization_iterations"
        ],
        "doc": "Advanced settings for the solver"
    },
    {
        "pointer": "/solver/advanced/cache_size",
        "default": 900000,
        "type": "int",
        "doc": "Maximum number of elements when the assembly values are cached."
    },
    {
        "pointer": "/solver/advanced/lump_mass_matrix",
        "default": false,
        "type": "bool",
        "doc": "If true, use diagonal mass matrix with entries on the diagonal equal to the sum of entries in each row of the full mass matrix.}"
    },
    {
        "pointer": "/solver/advanced/lagged_regularization_weight",
        "default": 0,
        "type": "float",
        "doc": "Weight used to regularize singular static problems."
    },
    {
        "pointer": "/solver/advanced/lagged_regularization_iterations",
        "default": 1,
        "type": "int",
        "doc": "Number of regularize singular static problems."
    },
    {
        "pointer": "/materials",
        "type": "list",
        "doc": "Material Parameters lists including ID pointing to volume selection, Young's modulus ($E$), Poisson's ratio ($\\nu$), Density ($\\rho$), or Lamé constants ($\\lambda$ and $\\mu$)."
    },
    {
        "pointer": "/materials/*",
        "type": "object",
        "type_name": "NeoHookean",
        "required": [
            "type",
            "E",
            "nu"
        ],
        "optional": [
            "id",
            "rho"
        ],
        "doc": "Material Parameters including ID, Young's modulus ($E$), Poisson's ratio ($\\nu$), density ($\\rho$)"
    },
    {
        "pointer": "/materials/*",
        "type": "object",
        "type_name": "NeoHookean",
        "required": [
            "type",
            "lambda",
            "mu"
        ],
        "optional": [
            "id",
            "rho"
        ],
        "doc": "Material Parameters including ID, Lamé first ($\\lambda$), Lamé second ($\\mu$), density ($\\rho$)"
    },
    {
        "pointer": "/materials/*",
        "type": "object",
        "type_name": "LinearElasticity",
        "required": [
            "type",
            "E",
            "nu"
        ],
        "optional": [
            "id",
            "rho"
        ],
        "doc": "Material Parameters including ID, Young's modulus ($E$), Poisson's ratio ($\\nu$), density ($\\rho$)"
    },
    {
        "pointer": "/materials/*",
        "type": "object",
        "type_name": "LinearElasticity",
        "required": [
            "type",
            "lambda",
            "mu"
        ],
        "optional": [
            "id",
            "rho"
        ],
        "doc": "Material Parameters including ID, Lamé first ($\\lambda$), Lamé second ($\\mu$), density ($\\rho$)"
    },
    {
        "pointer": "/materials/*",
        "type": "object",
        "type_name": "HookeLinearElasticity",
        "required": [
            "type",
            "E",
            "nu"
        ],
        "optional": [
            "id",
            "rho"
        ],
        "doc": "Material Parameters including ID, E, nu, density ($\\rho$)"
    },
    {
        "pointer": "/materials/*",
        "type": "object",
        "type_name": "HookeLinearElasticity",
        "required": [
            "type",
            "elasticity_tensor"
        ],
        "optional": [
            "id",
            "rho"
        ],
        "doc": "Material Parameters including ID, E, nu, density ($\\rho$)"
    },
    {
        "pointer": "/materials/*",
        "type": "object",
        "type_name": "SaintVenant",
        "required": [
            "type",
            "E",
            "nu"
        ],
        "optional": [
            "id",
            "rho"
        ],
        "doc": "Material Parameters including ID, E, nu, density ($\\rho$)"
    },
    {
        "pointer": "/materials/*",
        "type": "object",
        "type_name": "SaintVenant",
        "required": [
            "type",
            "elasticity_tensor"
        ],
        "optional": [
            "id",
            "rho"
        ],
        "doc": "Material Parameters including ID, E, nu, density ($\\rho$)"
    },
    {
        "pointer": "/materials/*",
        "type": "object",
        "type_name": "Stokes",
        "required": [
            "type",
            "viscosity"
        ],
        "optional": [
            "id",
            "rho"
        ],
        "doc": "Material Parameters including ID, viscosity, density ($\\rho$)"
    },
    {
        "pointer": "/materials/*",
        "type": "object",
        "type_name": "NavierStokes",
        "required": [
            "type",
            "viscosity"
        ],
        "optional": [
            "id",
            "rho"
        ],
        "doc": "Material Parameters including ID, viscosity, density ($\\rho$)"
    },
    {
        "pointer": "/materials/*",
        "type": "object",
        "type_name": "IncompressibleLinearElasticity",
        "required": [
            "type",
            "E",
            "nu"
        ],
        "optional": [
            "id",
            "rho"
        ],
        "doc": "Material Parameters including ID, Young's modulus ($E$), Poisson's ratio ($\\nu$), density ($\\rho$)"
    },
    {
        "pointer": "/materials/*",
        "type": "object",
        "type_name": "IncompressibleLinearElasticity",
        "required": [
            "type",
            "lambda",
            "mu"
        ],
        "optional": [
            "id",
            "rho"
        ],
        "doc": "Material Parameters including ID, Lamé first ($\\lambda$), Lamé second ($\\mu$), density ($\\rho$)"
    },
    {
        "pointer": "/materials/*",
        "type": "object",
        "type_name": "Laplacian",
        "required": [
            "type"
        ],
        "optional": [
            "id",
            "rho"
        ],
        "doc": "Material Parameters including ID, density ($\\rho$)"
    },
    {
        "pointer": "/materials/*",
        "type": "object",
        "type_name": "Helmholtz",
        "required": [
            "type"
        ],
        "optional": [
            "id",
            "rho",
            "k"
        ],
        "doc": "Material Parameters including ID, k, density ($\\rho$)"
    },
    {
        "pointer": "/materials/*",
        "type": "object",
        "type_name": "Bilaplacian",
        "required": [
            "type"
        ],
        "optional": [
            "id",
            "rho"
        ],
        "doc": "Material Parameters including ID, density ($\\rho$)"
    },
    {
        "pointer": "/materials/*/id",
        "type": "int",
        "default": 0,
        "doc": "Volume selection ID"
    },
    {
        "pointer": "/materials/*/E",
        "type": "float",
        "doc": "Young's modulus"
    },
    {
        "pointer": "/materials/*/nu",
        "type": "float",
        "doc": "Poisson's ratio"
    },
    {
        "pointer": "/materials/*/viscosity",
        "type": "float",
        "doc": "Fuild's viscosity"
    },
    {
        "pointer": "/materials/*/elasticity_tensor",
        "type": "list",
        "default": [],
        "doc": "Symmetric elasticity tensor"
    },
    {
        "pointer": "/materials/*/elasticity_tensor/*",
        "type": "float",
        "default": 0,
        "doc": "Entries of elasticity tensor"
    },
    {
        "pointer": "/materials/*/rho",
        "type": "float",
        "doc": "Density",
        "default": 1
    },
    {
        "pointer": "/materials/*/k",
        "type": "float",
        "doc": "Scaling for Helmholtz",
        "default": 1
    },
    {
        "pointer": "/materials/*/type",
        "type": "string",
        "options": [
            "LinearElasticity",
            "HookeLinearElasticity",
            "SaintVenant",
            "NeoHookean",
            "Stokes",
            "NavierStokes",
            "IncompressibleLinearElasticity",
            "Laplacian",
            "Helmholtz",
            "Bilaplacian"
        ],
        "doc": "Type of material"
    },
    {
        "pointer": "/materials/*/mu",
        "type": "float",
        "doc": "First Lamé parameters"
    },
    {
        "pointer": "/materials/*/lambda",
        "type": "float",
        "doc": "Second Lamé parameter"
    },
    {
        "pointer": "/boundary_conditions",
        "default": null,
        "type": "object",
        "optional": [
            "rhs",
            "dirichlet_boundary",
            "neumann_boundary",
            "pressure_boundary",
            "obstacle_displacements"
        ],
        "doc": "The settings for boundary conditions."
    },
    {
        "pointer": "/boundary_conditions/rhs",
        "type": "float",
        "doc": "Right-hand side of the system being solved for scalar-valued PDEs"
    },
    {
        "pointer": "/boundary_conditions/rhs",
        "type": "string",
        "doc": "Right-hand side of the system being solved as a function of $x,y,z,t$."
    },
    {
        "pointer": "/boundary_conditions/rhs",
        "default": [],
        "type": "list",
        "doc": "Right-hand side of the system being solved for vector-valued PDEs."
    },
    {
        "pointer": "/boundary_conditions/rhs/*",
        "default": 0,
        "type": "float",
        "doc": "Right-hand side of the system being solved, value."
    },
    {
        "pointer": "/boundary_conditions/rhs/*",
        "type": "string",
        "doc": "Right-hand side of the system being solved as a function of $x,y,z,t$."
    },
    {
        "pointer": "/boundary_conditions/dirichlet_boundary",
        "default": [],
        "type": "list",
        "doc": "The list of Dirichlet boundary conditions for the main variable. Elements of the list are assignment pairs (ID, value) where ID is assigned by surface selection."
    },
    {
        "pointer": "/boundary_conditions/dirichlet_boundary/*",
        "type": "object",
        "default": null,
        "required": [
            "id",
            "value"
        ],
        "optional": [
            "dimension"
        ],
        "doc": "Dirichlet boundary condition."
    },
    {
        "pointer": "/boundary_conditions/dirichlet_boundary/*",
        "type": "string",
        "doc": "Dirichlet boundary condition loaded from a file, <node_id> <bc values>, 1 for scalar, 2/3 for tensor depending on dimension."
    },
    {
        "pointer": "/boundary_conditions/dirichlet_boundary/*/id",
        "type": "int",
        "doc": "ID of Dirichlet boundary condition from surface selection."
    },
    {
        "pointer": "/boundary_conditions/dirichlet_boundary/*/id",
        "type": "string",
        "options": [
            "all"
        ],
        "doc": "select all ids."
    },
    {
        "pointer": "/boundary_conditions/dirichlet_boundary/*/value",
        "type": "list",
        "doc": "Values of Dirichlet boundary condition, length 1 for scalar-valued pde, 2/3 for vector-valued PDEs depending on the dimension."
    },
    {
        "pointer": "/boundary_conditions/dirichlet_boundary/*/value/*",
        "type": "string",
        "doc": "Values of Dirichlet boundary condition for each dimension as a function of $x,y,z,t$."
    },
    {
        "pointer": "/boundary_conditions/dirichlet_boundary/*/value/*",
        "type": "float",
        "doc": "Values of Dirichlet boundary condition for each dimension."
    },
    {
        "pointer": "/boundary_conditions/dirichlet_boundary/*/dimension",
        "type": "list",
        "default": [
            true,
            true,
            true
        ],
        "doc": "List of 2 (2D) or 3 (3D) boolean values indicating if the Dirichlet boundary condition  is applied for a particular dimension."
    },
    {
        "pointer": "/boundary_conditions/dirichlet_boundary/*/dimension/*",
        "type": "bool",
        "default": true,
        "doc": "value"
    },
    {
        "pointer": "/boundary_conditions/neumann_boundary",
        "default": [],
        "type": "list",
        "doc": "The list of Neumann boundary conditions for the main variable. Elements of the list are assignment pairs (ID, value) where ID is assigned by surface selection."
    },
    {
        "pointer": "/boundary_conditions/neumann_boundary/*",
        "type": "object",
        "default": null,
        "optional": [
            "id",
            "value"
        ],
        "doc": "Neumann boundary condition"
    },
    {
        "pointer": "/boundary_conditions/neumann_boundary/*/id",
        "type": "int",
        "default": 1,
        "doc": "ID of Neumann boundary condition"
    },
    {
        "pointer": "/boundary_conditions/neumann_boundary/*/value",
        "type": "list",
        "default": [],
        "doc": "Values of Neumann boundary condition for each dimension"
    },
    {
        "pointer": "/boundary_conditions/neumann_boundary/*/value/*",
        "type": "string",
        "default": "",
        "doc": "Values of Neumann boundary condition for each dimension as function of $x,y,z,t$"
    },
    {
        "pointer": "/boundary_conditions/neumann_boundary/*/value/*",
        "type": "float",
        "default": 0,
        "doc": "Values of Neumann boundary condition for each dimension"
    },
    {
        "pointer": "/boundary_conditions/pressure_boundary",
        "default": [],
        "type": "list",
        "doc": "Dirichlet boundary condition for normal * value for vector-valued PDEs."
    },
    {
        "pointer": "/boundary_conditions/pressure_boundary/*",
        "type": "object",
        "default": null,
        "required": [
            "id",
            "value"
        ],
        "optional": [
            "dimension"
        ],
        "doc": "pressure BC entry"
    },
    {
        "pointer": "/boundary_conditions/pressure_boundary/*/id",
        "type": "int",
        "doc": "ID for the pressure Neumann boundary condition"
    },
    {
        "pointer": "/boundary_conditions/pressure_boundary/*/value",
        "type": "list",
        "doc": "Values of pressure Neumann boundary condition"
    },
    {
        "pointer": "/boundary_conditions/pressure_boundary/*/value/*",
        "type": "string",
        "doc": "Values of pressure Neumann boundary condition as a function of $x,y,z,t$"
    },
    {
        "pointer": "/boundary_conditions/pressure_boundary/*/value/*",
        "type": "float",
        "doc": "Values of pressure Neumann boundary condition"
    },
    {
        "pointer": "/boundary_conditions/obstacle_displacements",
        "default": [],
        "type": "list",
        "doc": "The list of obstacle displacements. Each entry is an (ID, value) pair, where ids are set by selection."
    },
    {
        "pointer": "/boundary_conditions/obstacle_displacements/*",
        "type": "object",
        "default": null,
        "required": [
            "id",
            "value"
        ],
        "doc": "Obstacle displacements"
    },
    {
        "pointer": "/boundary_conditions/obstacle_displacements/*/id",
        "type": "int",
        "doc": "ID of Obstacle displacements"
    },
    {
        "pointer": "/boundary_conditions/obstacle_displacements/*/value",
        "type": "list",
        "doc": "Values of Obstacle displacements for each dimension"
    },
    {
        "pointer": "/boundary_conditions/obstacle_displacements/*/value/*",
        "type": "string",
        "doc": "Values of Obstacle displacements for each dimension as a function of $x,y,z,t$"
    },
    {
        "pointer": "/boundary_conditions/obstacle_displacements/*/value/*",
        "type": "float",
        "doc": "Values of Obstacle displacements for each dimension"
    },
    {
        "pointer": "/initial_conditions",
        "default": null,
        "type": "object",
        "optional": [
            "solution",
            "velocity",
            "acceleration"
        ],
        "doc": "Initial conditions for the time-dependent problem, imposed on the main variable, its derivative or second derivative"
    },
    {
        "pointer": "/initial_conditions/solution",
        "default": [],
        "type": "list",
        "doc": "initial solution"
    },
    {
        "pointer": "/initial_conditions/solution/*",
        "default": null,
        "type": "object",
        "required": [
            "id",
            "value"
        ],
        "doc": "A list of (ID, value) pairs defining the initial conditions for the main variable values. Ids are set by selection, and values can be floats or formulas."
    },
    {
        "pointer": "/initial_conditions/solution/*/id",
        "type": "int",
        "doc": "ID from volume selections"
    },
    {
        "pointer": "/initial_conditions/solution/*/value",
        "type": "list",
        "doc": "value of the solution"
    },
    {
        "pointer": "/initial_conditions/solution/*/value/*",
        "type": "float",
        "doc": "value"
    },
    {
        "pointer": "/initial_conditions/solution/*/value/*",
        "type": "string",
        "doc": "as a function of $x,y,z,t$"
    },
    {
        "pointer": "/initial_conditions/velocity",
        "default": [],
        "type": "list",
        "doc": "initial velocity"
    },
    {
        "pointer": "/initial_conditions/velocity/*",
        "default": null,
        "type": "object",
        "required": [
            "id",
            "value"
        ],
        "doc": "A list of (ID, value) pairs defining the initial conditions for the first derivative of the main variable values. Ids are set by selection, and values can be floats or formulas."
    },
    {
        "pointer": "/initial_conditions/velocity/*/id",
        "type": "int",
        "doc": "ID from volume selections"
    },
    {
        "pointer": "/initial_conditions/velocity/*/value",
        "type": "list",
        "min": 2,
        "max": 3,
        "doc": "value od the initial velocity"
    },
    {
        "pointer": "/initial_conditions/velocity/*/value/*",
        "type": "float",
        "doc": "value"
    },
    {
        "pointer": "/initial_conditions/velocity/*/value/*",
        "type": "string",
        "doc": "value as a function of $x,y,z,t$"
    },
    {
        "pointer": "/initial_conditions/acceleration",
        "default": [],
        "type": "list",
        "doc": "initial acceleration"
    },
    {
        "pointer": "/initial_conditions/acceleration/*",
        "default": null,
        "type": "object",
        "required": [
            "id",
            "value"
        ],
        "doc": "entries"
    },
    {
        "pointer": "/initial_conditions/acceleration/*/id",
        "type": "int",
        "doc": "ID from volume selections"
    },
    {
        "pointer": "/initial_conditions/acceleration/*/value",
        "type": "list",
        "min": 2,
        "max": 3,
        "doc": "value"
    },
    {
        "pointer": "/initial_conditions/acceleration/*/value/*",
        "type": "float",
        "default": 0,
        "doc": "value"
    },
    {
        "pointer": "/initial_conditions/acceleration/*/value/*",
        "type": "string",
        "doc": "value as a function of $x,y,z,t$"
    },
    {
        "pointer": "/output",
        "default": null,
        "type": "object",
        "optional": [
            "json",
            "paraview",
            "data",
            "advanced",
            "reference"
        ],
        "doc": "output settings"
    },
    {
        "pointer": "/output/json",
        "default": "",
        "type": "string",
        "doc": "File name for json output statistics on time/error/etc."
    },
    {
        "pointer": "/output/paraview",
        "default": null,
        "type": "object",
        "optional": [
            "file_name",
            "vismesh_rel_area",
            "skip_frame",
            "high_order_mesh",
            "volume",
            "surface",
            "wireframe",
            "options"
        ],
        "doc": "Output in paraview format"
    },
    {
        "pointer": "/output/paraview/file_name",
        "default": "",
        "type": "string",
        "doc": "Paraview output file name"
    },
    {
        "pointer": "/output/paraview/vismesh_rel_area",
        "default": 1e-05,
        "type": "float",
        "doc": "relative area for the upsampled visualisation mesh"
    },
    {
        "pointer": "/output/paraview/skip_frame",
        "default": 1,
        "type": "int",
        "doc": "export every skip_frame-th frames for time dependent simulations"
    },
    {
        "pointer": "/output/paraview/high_order_mesh",
        "default": true,
        "type": "bool",
        "doc": "Enables/disables high-order output for paraview. Supported only for isoparametric or linear meshes with high-odrer solutions."
    },
    {
        "pointer": "/output/paraview/volume",
        "default": true,
        "type": "bool",
        "doc": "Export volumetric mesh"
    },
    {
        "pointer": "/output/paraview/surface",
        "default": false,
        "type": "bool",
        "doc": "Export surface mesh (in 2d polygon)"
    },
    {
        "pointer": "/output/paraview/wireframe",
        "default": false,
        "type": "bool",
        "doc": "Export the wireframe of the mesh"
    },
    {
        "pointer": "/output/paraview/options",
        "default": null,
        "type": "object",
        "optional": [
            "material",
            "body_ids",
            "contact_forces",
            "friction_forces",
            "velocity",
            "acceleration"
        ],
        "doc": "Optional fields in the output"
    },
    {
        "pointer": "/output/paraview/options/material",
        "default": false,
        "type": "bool",
        "doc": "If true, write out material values sampled on the vertices of the mesh"
    },
    {
        "pointer": "/output/paraview/options/body_ids",
        "default": false,
        "type": "bool",
        "doc": "Export volumes ids"
    },
    {
        "pointer": "/output/paraview/options/contact_forces",
        "default": false,
        "type": "bool",
        "doc": "If true, write out contact forces for surface"
    },
    {
        "pointer": "/output/paraview/options/friction_forces",
        "default": false,
        "type": "bool",
        "doc": "If true, write out friction forces for surface"
    },
    {
        "pointer": "/output/paraview/options/velocity",
        "default": false,
        "type": "bool",
        "doc": "If true, write out velocities"
    },
    {
        "pointer": "/output/paraview/options/acceleration",
        "default": false,
        "type": "bool",
        "doc": "If true, write out accelerations"
    },
    {
        "pointer": "/output/data",
        "default": null,
        "type": "object",
        "optional": [
            "solution",
            "full_mat",
            "stiffness_mat",
            "stress_mat",
            "u_path",
            "v_path",
            "a_path",
            "mises",
            "nodes",
            "advanced"
        ],
        "doc": "File names to write output data to."
    },
    {
        "pointer": "/output/data/solution",
        "default": "",
        "type": "string",
        "doc": "Main variable solution. Unrolled [xyz, xyz, ...] using PolyFEM ordering. If reorder_nodes exports the solution with the same order the vertices of the input mesh as a #n x d file"
    },
    {
        "pointer": "/output/data/full_mat",
        "default": "",
        "type": "string",
        "doc": "System matrix without boundary conditions. Doesn't work for nonlinear problems"
    },
    {
        "pointer": "/output/data/stiffness_mat",
        "default": "",
        "type": "string",
        "doc": "System matrix with boundary conditions. Doesn't work for nonlinear problems"
    },
    {
        "pointer": "/output/data/stress_mat",
        "default": "",
        "type": "string",
        "doc": "Exports stress"
    },
    {
        "pointer": "/output/data/u_path",
        "default": "",
        "type": "string",
        "doc": "Writes the complete solution in PolyFEM format, used to restart the sim"
    },
    {
        "pointer": "/output/data/v_path",
        "default": "",
        "type": "string",
        "doc": "Writes the complete velocity in PolyFEM format, used to restart the sim"
    },
    {
        "pointer": "/output/data/a_path",
        "default": "",
        "type": "string",
        "doc": "Writes the complete acceleration in PolyFEM format, used to restart the sim"
    },
    {
        "pointer": "/output/data/mises",
        "default": "",
        "type": "string",
        "doc": "File name to write per-node Von Mises stress values to."
    },
    {
        "pointer": "/output/data/nodes",
        "default": "",
        "type": "string",
        "doc": "Writes the FEM nodes"
    },
    {
        "pointer": "/output/data/advanced",
        "default": null,
        "type": "object",
        "optional": [
            "reorder_nodes"
        ],
        "doc": "advanced options"
    },
    {
        "pointer": "/output/data/advanced/reorder_nodes",
        "default": false,
        "type": "bool",
        "doc": "Reorder nodes accodring to input"
    },
    {
        "pointer": "/output/reference",
        "default": null,
        "optional": [
            "solution",
            "gradient"
        ],
        "type": "object",
        "doc": "Write out the analytic/numerical ground-truth solution and or its gradient"
    },
    {
        "pointer": "/output/reference/solution",
        "default": [],
        "type": "list",
        "doc": "reference solution used to compute errors"
    },
    {
        "pointer": "/output/reference/solution/*",
        "default": "",
        "type": "string",
        "doc": "value as a function of $x,y,z,t$"
    },
    {
        "pointer": "/output/reference/gradient",
        "default": [],
        "type": "list",
        "doc": "gradient of the reference solution to compute errors"
    },
    {
        "pointer": "/output/reference/gradient/*",
        "default": "",
        "type": "string",
        "doc": "value as a function of $x,y,z,t$"
    },
    {
        "pointer": "/output/advanced",
        "default": null,
        "type": "object",
        "optional": [
            "timestep_prefix",
            "sol_on_grid",
            "compute_error",
            "sol_at_node",
            "vis_boundary_only",
            "curved_mesh_size",
            "save_solve_sequence_debug",
            "save_time_sequence",
            "save_nl_solve_sequence",
            "spectrum"
        ],
        "doc": "Additional output options"
    },
    {
        "pointer": "/output/advanced/timestep_prefix",
        "default": "step_",
        "type": "string",
        "doc": "Prefix for output file names for each time step, the final file is step_i.[vtu|vtm] where i is the time index."
    },
    {
        "pointer": "/output/advanced/sol_on_grid",
        "default": -1,
        "type": "float",
        "doc": "exports the solution sampled on a grid, specify the grid spacing"
    },
    {
        "pointer": "/output/advanced/compute_error",
        "default": true,
        "type": "bool",
        "doc": "Enables the computation of the error. If no reference solution is provided, return the norms of the solution"
    },
    {
        "pointer": "/output/advanced/sol_at_node",
        "default": -1,
        "type": "int",
        "doc": "Write out solution values at a specific node. the values will be written in the output json file"
    },
    {
        "pointer": "/output/advanced/vis_boundary_only",
        "default": false,
        "type": "bool",
        "doc": "saves only elements touching the boundaries"
    },
    {
        "pointer": "/output/advanced/curved_mesh_size",
        "default": false,
        "type": "bool",
        "doc": "upsample curved edges to compute mesh size"
    },
    {
        "pointer": "/output/advanced/save_solve_sequence_debug",
        "default": false,
        "type": "bool",
        "doc": "saves AL internal steps, for debugging"
    },
    {
        "pointer": "/output/advanced/save_time_sequence",
        "default": true,
        "type": "bool",
        "doc": "saves timesteps"
    },
    {
        "pointer": "/output/advanced/save_nl_solve_sequence",
        "default": false,
        "type": "bool",
        "doc": "saves obj after every nonlinear iteration, for debugging"
    },
    {
        "pointer": "/output/advanced/spectrum",
        "default": false,
        "type": "bool",
        "doc": "exports the spectrum of the matrix in the output json. Works only if POLYSOLVE_WITH_SPECTRA is enabled"
    },
    {
        "pointer": "/input",
        "default": null,
        "type": "object",
        "optional": [
            "data"
        ],
        "doc": "input data"
    },
    {
        "pointer": "/input/data",
        "default": null,
        "type": "object",
        "optional": [
            "u_path",
            "v_path",
            "a_path"
        ],
        "doc": "input to restart time dependent sim"
    },
    {
        "pointer": "/input/data/u_path",
        "default": "",
        "type": "string",
        "doc": "input solution"
    },
    {
        "pointer": "/input/data/v_path",
        "default": "",
        "type": "string",
        "doc": "input velocity"
    },
    {
        "pointer": "/input/data/a_path",
        "default": "",
        "type": "string",
        "doc": "input acceleration"
    },
    {
        "pointer": "/preset_problem",
        "default": "skip",
        "type_name": "Linear",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "Quadratic",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "Cubic",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "Sine",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "Franke",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "FrankeOld",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "GenericScalarExact",
        "type": "object",
        "required": [
            "type"
        ],
        "optional": [
            "func"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem/func",
        "type": "int",
        "default": 0,
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "Zero_BC",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "Elastic",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "Walk",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "TorsionElastic",
        "type": "object",
        "required": [
            "type"
        ],
        "optional": [
            "axis_coordiante",
            "n_turns",
            "fixed_boundary",
            "turning_boundary",
            "bbox_center"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem/axis_coordiante",
        "type": "int",
        "default": 2,
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem/n_turns",
        "type": "float",
        "default": 0.5,
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem/fixed_boundary",
        "type": "int",
        "default": 5,
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem/turning_boundary",
        "type": "int",
        "default": 6,
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem/bbox_center",
        "type": "list",
        "default": [],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem/bbox_center/*",
        "type": "float",
        "default": 0,
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "DoubleTorsionElastic",
        "type": "object",
        "required": [
            "type"
        ],
        "optional": [
            "axis_coordiante0",
            "axis_coordiante1",
            "angular_v0",
            "angular_v1",
            "turning_boundary0",
            "turning_boundary1",
            "bbox_center"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem/axis_coordiante0",
        "type": "int",
        "default": 2,
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem/axis_coordiante1",
        "type": "int",
        "default": 2,
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem/angular_v0",
        "type": "float",
        "default": 0.5,
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem/angular_v1",
        "type": "float",
        "default": -0.5,
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem/turning_boundary0",
        "type": "int",
        "default": 5,
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem/turning_boundary1",
        "type": "int",
        "default": 6,
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "ElasticZeroBC",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "ElasticExact",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "ElasticCantileverExact",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO, add displacement, E, nu, formulation, mesh_size"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "CompressionElasticExact",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "QuadraticElasticExact",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "LinearElasticExact",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "PointBasedTensor",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO, add optionals"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "Kernel",
        "type": "object",
        "required": [
            "type"
        ],
        "optional": [
            "formulation",
            "n_kernels",
            "kernel_distance",
            "kernel_weights"
        ],
        "doc": "TODO, add optionals"
    },
    {
        "pointer": "/preset_problem/formulation",
        "type": "string",
        "default": "",
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem/n_kernels",
        "type": "int",
        "default": 0,
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem/kernel_distance",
        "type": "float",
        "default": 0,
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem/kernel_weights",
        "type": "string",
        "default": "",
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "Node",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO, add optionals"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "TimeDependentScalar",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "MinSurf",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "Gravity",
        "type": "object",
        "required": [
            "type"
        ],
        "optional": [
            "force"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem/n_kernels/force",
        "type": "list",
        "default": [],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem/n_kernels/force/*",
        "type": "float",
        "default": 0,
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "ConstantVelocity",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "TwoSpheres",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "DrivenCavity",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "DrivenCavityC0",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "DrivenCavitySmooth",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "Flow",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO, add inflow, outflow, inflow_amout, outflow_amout, direction, obstacle"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "FlowWithObstacle",
        "type": "object",
        "required": [
            "type"
        ],
        "optional": [
            "U"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem/n_kernels/U",
        "type": "float",
        "default": 0,
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem/n_kernels/time_dependent",
        "type": "bool",
        "default": false,
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "CornerFlow",
        "type": "object",
        "required": [
            "type"
        ],
        "optional": [
            "U",
            "time_dependent"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "UnitFlowWithObstacle",
        "type": "object",
        "required": [
            "type"
        ],
        "optional": [
            "U"
        ],
        "doc": "TODO, add inflow_id, direction, no_slip"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "StokesLaw",
        "type": "object",
        "required": [
            "type"
        ],
        "optional": [
            "time_dependent",
            "viscosity"
        ],
        "doc": "TODO, add radius"
    },
    {
        "pointer": "/preset_problem/n_kernels/viscosity",
        "type": "float",
        "default": 0,
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "TaylorGreenVortex",
        "type": "object",
        "required": [
            "type"
        ],
        "optional": [
            "viscosity"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem/viscosity",
        "type": "float",
        "default": 1,
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "SimpleStokeProblemExact",
        "type": "object",
        "required": [
            "type"
        ],
        "optional": [
            "func"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "SineStokeProblemExact",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "TransientStokeProblemExact",
        "type": "object",
        "required": [
            "type"
        ],
        "optional": [
            "func",
            "viscosity"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "Kovnaszy",
        "type": "object",
        "required": [
            "type"
        ],
        "optional": [
            "viscosity"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "Airfoil",
        "type": "object",
        "required": [
            "type"
        ],
        "optional": [
            "time_dependent"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "Lshape",
        "type": "object",
        "required": [
            "type"
        ],
        "optional": [
            "U",
            "time_dependent"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "TestProblem",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO, type, omega, is_scalar"
    },
    {
        "pointer": "/preset_problem",
        "type_name": "BilaplacianProblemWithSolution",
        "type": "object",
        "required": [
            "type"
        ],
        "doc": "TODO, type, omega, is_scalar"
    },
    {
        "pointer": "/preset_problem/type",
        "type": "string",
        "doc": "Type of preset problem to use.",
        "options": [
            "Linear",
            "Quadratic",
            "Cubic",
            "Sine",
            "Franke",
            "FrankeOld",
            "GenericScalarExact",
            "Zero_BC",
            "Elastic",
            "Walk",
            "TorsionElastic",
            "DoubleTorsionElastic",
            "ElasticZeroBC",
            "ElasticExact",
            "ElasticCantileverExact",
            "CompressionElasticExact",
            "QuadraticElasticExact",
            "LinearElasticExact",
            "PointBasedTensor",
            "Kernel",
            "Node",
            "TimeDependentScalar",
            "MinSurf",
            "Gravity",
            "ConstantVelocity",
            "TwoSpheres",
            "DrivenCavity",
            "DrivenCavityC0",
            "DrivenCavitySmooth",
            "Flow",
            "FlowWithObstacle",
            "CornerFlow",
            "UnitFlowWithObstacle",
            "StokesLaw",
            "TaylorGreenVortex",
            "SimpleStokeProblemExact",
            "SineStokeProblemExact",
            "TransientStokeProblemExact",
            "Kovnaszy",
            "Airfoil",
            "Lshape",
            "TestProblem",
            "BilaplacianProblemWithSolution"
        ]
    }
]