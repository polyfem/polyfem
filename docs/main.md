# PolyFEM

![Build](https://github.com/polyfem/polyfem/workflows/Build/badge.svg)
![Commit](https://img.shields.io/github/last-commit/polyfem/polyfem)
[![License](https://img.shields.io/github/license/polyfem/polyfem.svg?color=blue)](https://github.com/polyfem/polyfem/blob/main/LICENSE)
[![Stars](https://img.shields.io/github/stars/polyfem/polyfem?style=social)](https://github.com/polyfem/polyfem)

## Code Structure

The high-level functions of PolyFEM are in `polyfem::State`, a class containing the application state and depending on all the PolyFEM submodules.

### Finite Element Assembler

`polyfem::assembler` assembles the system matrix and right hand side (rhs). The assembler relies on finite element basis (`polyfem::basis`), quadrature rules (`polyfem::quadrature`), and for transient problems on `polyfem::time_integrator`.

### Finite Element Bases

`polyfem::basis` contains the implementation of finite element basis functions. 

The module supports the following 2 dimensional elements:
* Lagrangian triangular elements of degree 1 to 8 (`FEBasis2d.hpp`)
* Lagrangian quadrilateral elements of degree 1 to 8 (`FEBasis2d.hpp`)
* Spline (IGA) elements of degree 1 to 4 (`SplineBasis2d.hpp`)
* Polygonal elements (`PolygonalBasis2d.hpp`)

The module supports the following 3 dimensional elements:
* Lagrangian tetrahedral elements of degree 1 to 8 (`FEBasis3d.hpp`)
* Lagrangian hexahedral elements of degree 1 to 8 (`FEBasis3d.hpp`)
* Spline (IGA) elements of degree 1 to 4 (`SplineBasis3d.hpp`)
* Polygonal elements (`PolygonalBasis3d.hpp`)

### Mesh data structure, Input/Output, and Navigation

`polyfem::mesh` contains data structures and algorithms for simplicial and polygonal meshes. 

The interface is generic (`Mesh2D.hpp`, `Mesh3D.hpp`). There are two specializations: a conforming implementation which supports conforming polygonal meshes (`CMesh2D.hpp`, `CMesh3D.hpp`) without hanging nodes, and a non-conforming version (`CMesh2D.hpp`, `CMesh3D.hpp`) specialized for simplicial meshes only but supporting hanging nodes, which are used to implement adaptive h-refinement.

Many input formats are supported (see the JSON documentation for the complete list), and it outputs meshes in VTU (the format used by paraview/VTK).

In PolyFEM the mesh is used to define a collection of dofs (in case of linear elements, they correspond to the nodes of the mesh, but this is not the case for other elements). The mesh is then discarded and not used by other modules.

### Quadrature Rules

`polyfem::quadrature` contains a set of quadrature rules for all elements implemented in `polyfem::basis`. The quadrature library is mostly independent from the rest of the codebase and it is based on the open-source library quadpy.

### Time Integration

For transient problems, `polyfem::time_integrator` implements first-order (Implicit Euler `ImplicitEuler.hpp`) and higher-order time integrators (Implicit Newmak `ImplicitNewmark.hpp`, BDF `BDF.hpp`).

### Collection of PDEs 

Polyfem contains right hand side, boundary conditions, exact solutions, and initial conditions for many common PDEs. We refer to the documentation in the `polyfem::problem` section for more details. The major physics supported by polyfem are:

1. Laplace
2. Helmholtz
3. Linear Elasticity
4. Saint-Venant Elasticity
5. Neo-Hookean Elasticity
6. Stokes
7. Navier-Stokes

From these, 1, 3--5, and 7 supports both static and transient problems, and 3--5 model contact and friction forces using the Incremental Potential Contact formulation (https://github.com/ipc-sim/ipc-toolkit).

### Automatic Code Generation

`polyfem::autogen` contains python scripts to generate C++ code for:
* Low-order basis in `polyfem::basis`
* All quadrature rules used in `polyfem::quadrature`
* All non-trivial rhs assembly in `polyfem::assembler`

The code autogenerated by the python scripts is directly committed in the code repository, as the autogeneration is time consuming.

### Utilities

Smaller utilities are grouped in the `polyfem::utils` module, including mesh IO, hashing functions, logging, matrix utilities, parallelization, rasterization, function interpolation (`RBFInterpolation.hpp`), and timers (`Timer.hpp`).

## Simple Example / Code Walkthrough

In this section, a brief code walkthrough for a simple example problem is given. 

### JSON File 

For this example, we solve the Laplacian on a Plate-Hole mesh. We choose XXX basis, XXX boundary conditions, 

```json
FILE CONTENTS

```

### Basis Building

After creating a `polyfem::State` object and loading the input mesh, the first step in the code is to build the basis. In PolyFEM, there are two separate notions of basis: the finite element (FE) basis and the geometric basis. The la

### Matrix Assembly

The next step is assembling the linear system 

### Solver

After 

### Diagram

![Setup diagram](img/example_setup.png)

#### Technical Note: Matrix Caching

In order to boost performance, PolyFEM caches sparsity structure when assembling matrices, taking advantage of the fact that the structure of stiffness/mass matrices remains unchanged assuming the basis is unchanged. The details can be found in `MatrixCache.hpp`. A brief overview of `polyfem::utils::SparseMatrixCache` is included here for reference. 

In PolyFEM, sparse matrices are stored in [Compressed Sparse Column (CSC)](https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS)) form. Thus, the matrix is represented as three arrays: two for storing non-zero indices and one for storing values. 

Consider the first time a `polyfem::utils::SparseMatrixCache` object is filled with values. Each time `SparseMatrixCache::add_value` is called, the values and their global indices are placed in a temporary buffer. It is assumed that a given `polyfem::utils::SparseMatrixCache` always receives each entry from a given element in the same order.

The first time the matrix is retrieved using `SparseMatrixCache::get_matrix`, the buffered values are written to the actual matrix. Then, the stored index information is used to create a mapping from the ordering of values received from a given element to the corresponding CSC-style index. In future iterations, instead of recomputing the matrix structure, `polyfem::utils::SparseMatrixCache` uses this cached index to save the given value directly to the CSC-style values array at the correct position. 

## Building PolyFEM as a stand-alone executable

All the C++ dependencies required to build the code are included and are compiled statically in a single executable. PolyFEM is compiled using automatic builds on Windows, macOS, and Linux using:

```bash
mkdir build
cd build
cmake ..
make -j4
```

After compilation, unit and system tests (`tests/main.cpp`) can be run with:

```bash
./tests/unit_tests
```

## Building PolyFEM as a static library

**Polyfem** can be added to an existing `cmake` project with
```cmake
add_subdirectory(<path-to-polyfem> polyfem)
```
and linked with
```cmake
target_link_library(<your_target> polyfem::polyfem)
```
in your cmake script. We do not currently support other building systems. PolyFEM will download the dependencies that it needs in the build folder.
