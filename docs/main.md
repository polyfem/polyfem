# PolyFEM

![Build](https://github.com/polyfem/polyfem/workflows/Build/badge.svg)
![Commit](https://img.shields.io/github/last-commit/polyfem/polyfem)
[![License](https://img.shields.io/github/license/polyfem/polyfem.svg?color=blue)](https://github.com/polyfem/polyfem/blob/main/LICENSE)
[![Stars](https://img.shields.io/github/stars/polyfem/polyfem?style=social)](https://github.com/polyfem/polyfem)

## Code Structure

The high-level functions of PolyFEM are in `polyfem::State`, a class containing the application state and depending on all the PolyFEM submodules.

### Finite Element Assembler

`polyfem::assembler` assembles the system matrix and right hand side (rhs). The assembler relies on finite element basis (`polyfem::basis`), quadrature rules (`polyfem::quadrature`), and for transient problems on `polyfem::time_integrator`.

### Finite Element Bases

`polyfem::basis` contains the implementation of finite element basis functions. 

The module supports the following 2 dimensional elements:
* Lagrangian triangular elements of degree 1 to 8 (`FEBasis2d.hpp`)
* Lagrangian quadrilateral elements of degree 1 to 8 (`FEBasis2d.hpp`)
* Spline (IGA) elements of degree 1 to 4 (`SplineBasis2d.hpp`)
* Polygonal elements (`PolygonalBasis2d.hpp`)

The module supports the following 3 dimensional elements:
* Lagrangian tetrahedral elements of degree 1 to 8 (`FEBasis3d.hpp`)
* Lagrangian hexahedral elements of degree 1 to 8 (`FEBasis3d.hpp`)
* Spline (IGA) elements of degree 1 to 4 (`SplineBasis3d.hpp`)
* Polygonal elements (`PolygonalBasis3d.hpp`)

### Mesh data structure, Input/Output, and Navigation

`polyfem::mesh` contains data structures and algorithms for simplicial and polygonal meshes. 

The interface is generic (`Mesh2D.hpp`, `Mesh3D.hpp`). There are two specializations: a conforming implementation which supports conforming polygonal meshes (`CMesh2D.hpp`, `CMesh3D.hpp`) without hanging nodes, and a non-conforming version (`CMesh2D.hpp`, `CMesh3D.hpp`) specialized for simplicial meshes only but supporting hanging nodes, which are used to implement adaptive h-refinement.

Many input formats are supported (see the JSON documentation for the complete list), and it outputs meshes in VTU (the format used by paraview/VTK).

In PolyFEM the mesh is used to define a collection of dofs (in case of linear elements, they correspond to the nodes of the mesh, but this is not the case for other elements). The mesh is then discarded and not used by other modules.

### Quadrature Rules

`polyfem::quadrature` contains a set of quadrature rules for all elements implemented in `polyfem::basis`. The quadrature library is mostly independent from the rest of the codebase and it is based on the open-source library quadpy.

### Time Integration

For transient problems, `polyfem::time_integrator` implements first-order (Implicit Euler `ImplicitEuler.hpp`) and higher-order time integrators (Implicit Newmak `ImplicitNewmark.hpp`, BDF `BDF.hpp`).

### Collection of PDEs 

Polyfem contains right hand side, boundary conditions, exact solutions, and initial conditions for many common PDEs. We refer to the documentation in the `polyfem::problem` section for more details. The major physics supported by polyfem are:

1. Laplace
2. Helmholtz
3. Linear Elasticity
4. Saint-Venant Elasticity
5. Neo-Hookean Elasticity
6. Stokes
7. Navier-Stokes

From these, 1, 3--5, and 7 supports both static and transient problems, and 3--5 model contact and friction forces using the Incremental Potential Contact formulation (https://github.com/ipc-sim/ipc-toolkit).

### Automatic Code Generation

`polyfem::autogen` contains python scripts to generate C++ code for:
* Low-order basis in `polyfem::basis`
* All quadrature rules used in `polyfem::quadrature`
* All non-trivial rhs assembly in `polyfem::assembler`

The code autogenerated by the python scripts is directly committed in the code repository, as the autogeneration is time consuming.

### Utilities

Smaller utilities are grouped in the `polyfem::utils` module, including mesh IO, hashing functions, logging, matrix utilities, parallelization, rasterization, function interpolation (`RBFInterpolation.hpp`), and timers (`Timer.hpp`).

## Building PolyFEM as a stand-alone executable

All the C++ dependencies required to build the code are included and are compiled statically in a single executable. PolyFEM is compiled using automatic builds on Windows, macOS, and Linux using:

```bash
mkdir build
cd build
cmake ..
make -j4
```

After compilation, unit and system tests (`tests/main.cpp`) can be run with:

```bash
./tests/unit_tests
```

## Building PolyFEM as a static library

**Polyfem** can be added to an existing `cmake` project with
```cmake
add_subdirectory(<path-to-polyfem> polyfem)
```
and linked with
```cmake
target_link_library(<your_target> polyfem::polyfem)
```
in your cmake script. We do not currently support other building systems. PolyFEM will download the dependencies that it needs in the build folder.
